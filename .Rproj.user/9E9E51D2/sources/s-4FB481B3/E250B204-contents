library(swirl)

# To do this week: 
# 1. lapply and sapply -- lesson 10
# 2. vapply and tapply -- lesson 11

# Start swirl and complete the lessons
swirl()
Andr√©s
1
10
head(flags)
dim(flags)
viewinfo()
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(flags, class)
cls_vect <- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[, 11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <- lapply(flags, unique)
unique_vals
sapply(unique_vals, length)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
# The only difference between previous examples and this one is that we are defining and using
# our own function right in the call to lapply(). Our function has no name and disappears as
# soon as lapply() is done using it. So-called 'anonymous functions' can be very useful when
# one of R's built-in functions isn't an option.
2
mail@andres.nu
1hMDYKbkCDQXcHQC
1
11
sapply(flags, unique)

# When working interactively (at the prompt), this is not much of a problem, since you see the
# result immediately and will quickly recognize your mistake. However, when working
# non-interactively (e.g. writing your own functions), a misunderstanding may go undetected
# and cause incorrect results later on. Therefore, you may wish to be more careful and that's
# where vapply() is useful.
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags,class, character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$red[flags$red== 0], median)
11
1
2
3
tapply(flags$population, flags$landmass, summary)
mail@andres.nu
Z3wfJJmPHGnpJ0w82
2
mail@andres.nu
Z3wfJJmPHGnpJ0w8
